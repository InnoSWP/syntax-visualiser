function g(e,t,s,r=1){var n;s(e,r);const a=(n=t(e))!=null?n:[];for(const u of a)g(u,t,s,r+1)}function v(e,t,s){const r=e.parse(t,s);return r.success?{success:!0,nodes:N(r.astRoot,e)}:r}function N(e,t){const{getNodeType:s,getNodeJsonSerializableMetadata:r,getNodeLocation:a,getNodeLabel:n,getNodeChildren:u}=t,o=[];return g(e,u,(c,b)=>{var f,m;o.push({type:s(c),meta:r(c),depth:b,location:(f=a(c))!=null?f:void 0,label:(m=n(c))!=null?m:void 0})}),y(o),o}function y(e){const t=Math.max(...e.map(a=>a.depth)),s=Array(t).fill(0),r=Array(t).fill(null);for(const[a,n]of e.entries()){if(n.depth<=0)throw new Error(`Node depths should be 1-indexed, got ${n.depth}`);if(s[n.depth-1]++,n.coordinates=[...s.slice(0,n.depth),...Array(t-n.depth).fill(0)],!(n.depth===1)){const o=r[n.depth-2];if(o==null)throw new Error("Incorrect nodes, parent at previous depth is null");o.childrenIndexes||(o.childrenIndexes=[]),o.childrenIndexes.push(a)}r[n.depth-1]=n}}function I(e){switch(e){case"../languages/javascript/parsers/babel/implementation.ts":return import("./implementation-209542b2.js");default:return new Promise(function(t,s){(typeof queueMicrotask=="function"?queueMicrotask:setTimeout)(s.bind(null,new Error("Unknown variable dynamic import: "+e)))})}}let d=null,p=null,l=null,i=null;onmessage=e=>{const t=e.data;switch(t.type){case"parse":w(t),h();break;case"set-parser":l=t.parser,p!==l&&x(l).then(s=>{s.parser===l&&(p=s.parser,d=s.implementation,h())});break}};function w(e){i=e}function h(){if(i!=null&&d!=null&&p!=null&&p===l){const e=v(d,i.code,i.options),t={type:"parse-result",version:i.version,result:e};postMessage(t),i=null}}async function x(e){const[t,s]=e.split(">");return{parser:e,implementation:(await I(`../languages/${t}/parsers/${s}/implementation.ts`)).default}}
